// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#nullable enable

using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Management.Automation.Internal;
using System.Management.Automation.Runspaces;
using System.Management.Automation.Subsystem.Prediction;
using System.Threading;

namespace System.Management.Automation.Subsystem.Feedback
{
    /// <summary>
    /// Layout for displaying the recommended actions.
    /// </summary>
    public enum FeedbackDisplayLayout
    {
        /// <summary>
        /// Display one recommended action per row.
        /// </summary>
        Portrait,

        /// <summary>
        /// Display all recommended actions in the same row.
        /// </summary>
        Landscape,
    }

    /// <summary>
    /// The class represents a feedback item generated by the feedback provider.
    /// </summary>
    public sealed class FeedbackItem
    {
        /// <summary>
        /// Gets the description message about this feedback.
        /// </summary>
        public string Header { get; }

        /// <summary>
        /// Gets the footer message about this feedback.
        /// </summary>
        public string? Footer { get; }

        /// <summary>
        /// Gets the recommended actions -- command lines or even code snippets to run.
        /// </summary>
        public List<string>? RecommendedActions { get; }

        /// <summary>
        /// Gets the layout to use for displaying the recommended actions.
        /// </summary>
        public FeedbackDisplayLayout Layout { get; }

        /// <summary>
        /// Gets or sets the next feedback item, if there is one.
        /// </summary>
        public FeedbackItem? Next { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="FeedbackItem"/> class.
        /// </summary>
        /// <param name="header">The description message (must be not null or empty).</param>
        /// <param name="actions">The recommended actions to take (optional).</param>
        public FeedbackItem(string header, List<string>? actions)
            : this(header, actions, footer: null, FeedbackDisplayLayout.Portrait)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FeedbackItem"/> class.
        /// </summary>
        /// <param name="header">The description message (must be not null or empty).</param>
        /// <param name="actions">The recommended actions to take (optional).</param>
        /// <param name="layout">The layout for displaying the actions.</param>
        public FeedbackItem(string header, List<string>? actions, FeedbackDisplayLayout layout)
            : this(header, actions, footer: null, layout)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FeedbackItem"/> class.
        /// </summary>
        /// <param name="header">The description message (must be not null or empty).</param>
        /// <param name="actions">The recommended actions to take (optional).</param>
        /// <param name="footer">The footer message (optional).</param>
        /// <param name="layout">The layout for displaying the actions.</param>
        public FeedbackItem(string header, List<string>? actions, string? footer, FeedbackDisplayLayout layout)
        {
            ArgumentException.ThrowIfNullOrEmpty(header);

            Header = header;
            RecommendedActions = actions;
            Footer = footer;
            Layout = layout;
        }
    }

    /// <summary>
    /// Interface for implementing a feedback provider on command failures.
    /// </summary>
    public interface IFeedbackProvider : ISubsystem
    {
        /// <summary>
        /// Default implementation. No function is required for a feedback provider.
        /// </summary>
        Dictionary<string, string>? ISubsystem.FunctionsToDefine => null;

        /// <summary>
        /// Gets feedback based on the given commandline and error record.
        /// </summary>
        /// <param name="commandLine">The command line that was just executed.</param>
        /// <param name="lastError">The error that was triggerd by the command line.</param>
        /// <param name="token">The cancellation token to cancel the operation.</param>
        /// <returns>The feedback item.</returns>
        FeedbackItem? GetFeedback(string commandLine, ErrorRecord lastError, CancellationToken token);
    }

    internal sealed class GeneralCommandErrorFeedback : IFeedbackProvider
    {
        private readonly Guid _guid;

        internal GeneralCommandErrorFeedback()
        {
            _guid = new Guid("A3C6B07E-4A89-40C9-8BE6-2A9AAD2786A4");
        }

        public Guid Id => _guid;

        public string Name => "general";

        public string Description => "The built-in general feedback source for command errors.";

        public FeedbackItem? GetFeedback(string commandLine, ErrorRecord lastError, CancellationToken token)
        {
            var rsToUse = Runspace.DefaultRunspace;
            if (rsToUse is null)
            {
                return null;
            }

            if (lastError.FullyQualifiedErrorId == "CommandNotFoundException")
            {
                EngineIntrinsics context = rsToUse.ExecutionContext.EngineIntrinsics;

                var target = (string)lastError.TargetObject;
                CommandInvocationIntrinsics invocation = context.SessionState.InvokeCommand;

                // See if target is actually an executable file in current directory.
                var localTarget = Path.Combine(".", target);
                var command = invocation.GetCommand(
                    localTarget,
                    CommandTypes.Application | CommandTypes.ExternalScript);

                if (command is not null)
                {
                    return new FeedbackItem(
                        StringUtil.Format(SuggestionStrings.Suggestion_CommandExistsInCurrentDirectory, target),
                        new List<string> { localTarget });
                }

                // Check fuzzy matching command names.
                if (ExperimentalFeature.IsEnabled("PSCommandNotFoundSuggestion"))
                {
                    var pwsh = PowerShell.Create(RunspaceMode.CurrentRunspace);
                    var results = pwsh.AddCommand("Get-Command")
                            .AddParameter("UseFuzzyMatching")
                            .AddParameter("FuzzyMinimumDistance", 1)
                            .AddParameter("Name", target)
                        .AddCommand("Select-Object")
                            .AddParameter("First", 5)
                            .AddParameter("Unique")
                            .AddParameter("ExpandProperty", "Name")
                        .Invoke<string>();

                    if (results.Count > 0)
                    {
                        return new FeedbackItem(
                            SuggestionStrings.Suggestion_CommandNotFound,
                            new List<string>(results),
                            FeedbackDisplayLayout.Landscape);
                    }
                }
            }

            return null;
        }
    }
}
